\chapter{Security in Earnest I \small{\textsf{DRAFT}}}\label{chapter.earnest1}

% TODO: define $f$ and $\eta$ formally

We have spent the previous chapters developing our intuition about blockchain systems and why
they work. In this chapter and the next couple of chapters, we will formalize the notion of
security and prove that blockchains are secure. We start by making a few things more precise,
beginning with our hash function and the notion of time. Once we have specified these, we
will describe the environment that the parties operate in. This will make precise
the concept of a \emph{Sybil adversary} and the \emph{non-eclipsing assumption}, which we introduced informally
in Chapter~\ref{chapter.untrusty-world}, among other things.
Next, we will write out the protocol of the honest parties as exact pseudocode.
We will move on to formally prove the three chain virtues we explored intuitively:
Chain Growth, Common Prefix, and Chain Quality.
Finally, we will formally show that ledger virtues follow from chain virtues.

In order to prove the security of our systems,
we need to set the stage to explicitly define what it means to run the blockchain network as a
whole and analyze its properties. We want to be able to speak about an \emph{execution} of the network.
This execution needs to be a well-defined mathematical object so that we can precisely speak about
predicates on this object and determine, for example, whether the common prefix chain virtue held in a
particular execution, or if the safety ledger virtue was violated in another. To this end, we will
model the running of the whole blockchain network as a kind of simulation: We will instantiate multiple
honest machines running the honest code, and one adversarial machine running the adversarial code.
Whereas the honest code will be defined by us, the adversarial code will be free to be anything.
The machines will be polynomially bound, and formally they can be treated as Turing Machines (although
the precise details of the computational model of each machine are unimportant). Once these machines
are booted up, we will create all the plumbing and piping to orchestrate their execution and their
connection. We will define how they operate step by step, when each machine is ran, and how they
exchange messages with one another on the network.

Let us begin by discussing a model of how the hash function behaves in this network context.

\section{Random Oracle}\index{Random Oracle}

In Chapter~\ref{chapter.blocks}, we argued that the hash function behaves like a random
oracle and that $Pr[H(B) \leq T] = p = \frac{T}{2^k}$. Let us now make the random oracle
model more precise. We want the hash function to return a uniformly randomly chosen $\kappa$-bit
value whenever it is invoked with a fresh input. However, in order for it to be a function,
we want it to return the \emph{same} value when it is invoked again with the same input.
The random oracle is a shared functionality among all honest parties: If two different parties
invoke it, the oracle must answer consistently. This is illustrated in Algorithm~\ref{alg.ro}.
This consistency between different parties and multiple queries is necessary so that if
a party successfully mines a block, every other party will be able to verify that this
mining was successful.

\import{./}{algorithms/alg.ro}

The oracle keeps track of the randomnesses it has generated in a dictionary $\mathcal{T}$. If
the key $B$ queried has been queried before, the random oracle returns the cached value $\mathcal{T}[B]$.
Otherwise, the oracle generates a uniformly random $\kappa$-bit string, caches it in the $\mathcal{T}$
dictionary for future use, and returns it.

By introducing the random oracle model, we are treating the hash function as an idealized ``API''
or service that any party can query. It is important to understand that this is an idealized model
and not how real systems work. In real implementations of cryptocurrencies, the hash function is
computed locally by each party by a fast and deterministic algorithm that does not require reaching
out to an external service.

\section{Synchrony}\index{Synchrony Assumption}

To simplify our analysis, we will \emph{quantize} time. We will pretend that time progresses in
discrete \emph{rounds} that are numbered by the integers $1, 2, \ldots, L$. The honest parties
and the adversary execute in \emph{lockstep}: The execution begins at round $1$, and everyone gets
to take an action. When everyone has completed their actions for round $1$, the round concludes,
and round $2$ begins. Everyone gets to take an action during round $2$. When everyone has completed
their actions for round $2$, the round concludes, and so on, until the last round $L \in \mathbb{N}$
is reached. We call $L$ the system's \emph{lifetime}. This lockstep model with rounds is like
a turn-based game between the parties.

The actions of a party during a round are private to himself and not seen by the other parties.
For example, the adversary cannot directly observe the actions of an honest party. The only way for
the parties to exchange information is through the \emph{network}. Again, we will model the network as a
mathematical device, and abstract away the more concrete details of the gossip network that
we explored in Chapter~\ref{chapter.untrusty-world}. We allow each honest party to emit one or more messages
during its execution during a particular round. These messages are then collected by the network at the end
of the round and forwarded to all parties at the beginning of the next round. The phrases ``at the beginning''
and ``at the end'' of a round are narrative devices to aid understanding, but rounds are, in a sense,
instantaneous, and there is no communication between parties during the same round. Because messages
emitted by an honest during one round and received by every honest party by the beginning of the next round,
we are letting the network diameter $\Delta = 1$. Because $\Delta$ is unitless, we think of a round as exactly
the amount of time that a message takes to reach the whole network.

\begin{definition}[Synchronous Network]
    We say that the network is \emph{synchronous} if, whenever a message is emitted by an honest party at
    round $r$, that message is received by all honest parties by round $r+1$.
\end{definition}

In practice, on the modern Internet, the duration of one round is taken to be around $10$ seconds or so;
this is the time it takes for a message to reach all the honest parties, even those in remote locations,
when the gossip network over multiple hops is used.

This model synchronizes the arrival of messages such that they all arrive at the boundary of each round,
and lets us discretize time by eliminating complexities of network distance and speed. Furthermore, the execution
of our network entities is simplified to a ``lockstep execution'' model, where we can easily predict when
any node will receive a given message, which will be precisely one round after it was broadcast.

\section{The Simulation Environment}\index{Environment}
In order to rigorously define properties of our blockchain and give security proofs, we need to precisely define how we will simulate our environment: the setup and how each round happens.

\glsxtrnewsymbol[description={environment}]{environment}{$\mathcal{Z}$}\glsadd{environment}
\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.environment} The environment and network model running for a polynomial number of rounds $\textsf{poly}(\kappa)$.}
    \begin{algorithmic}[1]
        \State $r \leftarrow 0$
        \Function{$\mathcal{Z}^{n,t}_{\Pi,\mathcal{A}}$}{$1^\kappa$}
            \State{$\mathcal{G} \overset{\$}{\leftarrow} \{0, 1\}^\kappa$}
            \Comment{Genesis block}
            \For{$i \gets 1 \text{ to } n - t$}
                \Comment{Boot stateful honest parties}
                \State $P_i \leftarrow$ {\textsf{new }} $\Pi^{H_{\kappa,i}}(\mathcal{G})$
            \EndFor
            \State $A \leftarrow${\textsf{new }} $\mathcal{A}^{H_{\kappa,0}}(\mathcal{G}, n, t)$
            \Comment{Boot stateful adversary}
            \State $\overline{M} \leftarrow []$ \Comment{2D array of messages}
            \For{$i \gets 1 \text{ to } n - t$}
                \State $\overline{M}[i] \leftarrow []$ \Comment{Each honest party has an array of messages}
            \EndFor
            \While{$r < \textsf{poly}(\kappa)$} \Comment{Number of rounds}
                \State $r \leftarrow r + 1$
                \State $M \leftarrow \emptyset$
                \For{$i \gets 1 \text{ to } n - t$} \Comment{Execute honest party $i$ for round $r$}
                    \State $Q \leftarrow q$ \Comment{Maximum number of oracle queries per honest party (Section 2)}
                    \State $M \leftarrow M \cup \{P_i.\textsf{execute}^H(\overline{M}[i])\}$ \Comment{Adversary collects all messages}

                \EndFor
                \State $Q \leftarrow tq$ \Comment{Max number of Adversarial oracle queries}
                \State $\overline{M} \leftarrow A.\textsf{execute}^H(M)$
                \Comment{Execute rushing adversary for round $r$}
                \For{$m \in M$}\Comment{Ensure all parties will receive message $m$}
                    \For{$i \gets 1 \text{ to } n - t$}
                        \label{alg.environment.connectivity}
                        \State{$\textsf{assert}(m \in \overline{M}[i])$}\Comment{Non-eclipsing assumption}
                    \EndFor
                \EndFor
            \EndWhile
        \EndFunction
        \vskip8pt
    \end{algorithmic}
\end{algorithm}
\end{figure}

\subsection{A Simplification: Quantize Time}
Notice that we are running the simulation in rounds (line 12). In the real world, time is continuous, however by breaking down the simulation into short rounds, it makes it much easier to define and prove security properties of our blockchain. Furthermore, it makes it easier to define the properties of our adversary as seen below.

\subsection{Rushing Adversary}\index{Rushing Adversary}
In this environment, we are assuming a Rushing Adversary. This is because every round (lines 12-26), we first simulate the honest parties independently - they do not see the messages produced by each other that round - (lines 15-19), collect all the messages on the gossip network (line 17), then run the adversary with all the gossiped messages (line 20).

\subsection{Sybil Adversary \& Non-Eclipsing Assumption}
The adversary sees the messages gossiped by each honest party before the other honest parties. The adversary then has the power to manipulate what messages the honest parties will see next round in the following way

\begin{enumerate}
    \item The adversary can inject new messages
    \item The adversary can reorder messages
    \item The adversary can introduce disagreement
    \item The adversary cannot censor messages (lines 20, 21, 22)
\end{enumerate}
The fourth point is due to the Non-Eclipsing Assumption: since there is a path of honest parties between any two honest parties, and each honest party follows the algorithm detailed in section 3, we know that an honestly produced message will be propagated to all honest parties on the next round.

\section{Random Oracle Model}
In the simulation algorithm, for both the honest parties and adversarial parties we write {\textsf{execute}}$^H$ (lines 17, 20). This means that we model the hash function as a random oracle and give both the honest and adversarial parties Black-Box access to the oracle. This means that for any "new" input, the output is queried uniformly at random from the output space (line 10) and returned. Furthermore, when an input is queried for the first time, it is stored in a cache (stored in $\mathcal{T}$), therefore if the same input is later queried, the value is looked up in the cache and returned (line 12). Black-Box access means that the parties do not have access to the cache or the random sampling algorithm. They can only submit a query $x$ and receive a response $\mathcal{T}[x]$.
\\
Secondly, in order to model the hash rate, we give each party a maximum number of oracle queries per round. Each honest party receives $q$ queries, and the adversary receives $qt$ queries. (line 3, 9).
\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.hash} The Hash Function in the Random Oracle Model}
    \begin{algorithmic}[1]
        \State $r \leftarrow 0$
        \State $\mathcal{T} \leftarrow \{\}$ \Comment{Initiate Cache}
        \State $Q \leftarrow 0$ \Comment{$q$ for honest parties, $qt$ for adversary}
        \Function{$H_\kappa$}{$x$}
            \If{$x \not\in \mathcal{T}$} \Comment{First time being queried}
                \If{$Q = 0$} \Comment{Out of Queries}
                    \State\Return{$\bot$}
                \EndIf
                \State $Q \leftarrow Q - 1$
                \State$\mathcal{T}[x] \overset{\$}{\leftarrow} \{0, 1\}^\kappa$ \Comment{Sample uniformly at random from output space and store in Cache}
            \EndIf
            \State\Return$\mathcal{T}[x]$ \Comment{Return value from Cache}
        \EndFunction
        \vskip8pt
    \end{algorithmic}
\end{algorithm}
\end{figure}


\section{Honest Party Algorithm}
Below is a class of algorithms belonging to an honest party.
\\
\\
The first algorithm is a constructor.
\\
\\
The second algorithm is used to simulate every honest party that mines during each round of the protocol. In this simulation, every honest party follows the longest chain rule, at the beginning of each round they adopt the longest, valid chain (line 8). If they learn about a new chain that is longer then their current one, they gossip it (line 9,10). The honest party then tries to mine a block using the transactions in their mempool (line 12, 13). If a block is successfully mined, the honest party will gossip it.
\\
\\
The third algorithm is used to extract all transactions from a blockchain. This is useful when validating a new chain as we need to check all transactions starting from the genesis state to ensure that there are no invalid transactions and to maintain an up-to-date UTXO set.
\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.backbone} The honest party}
    \begin{algorithmic}[1]
     \Statex
     \State{$\mathcal{G}$}
     \Let{\chain}{[\,]}
        \Function{$\textsf{Constructor}$}{$\mathcal{G}'$}
            \State $\mathcal{G} \leftarrow \mathcal{G}'$ \Comment{Select Genesis Block}
            \State $\chain \leftarrow [\mathcal{G}]$ \Comment{Add Genesis Block to start of chain}
            \State \textsf{round} $\leftarrow 1$
        \EndFunction
        \Function{$\textsf{Execute}$}{$1^\kappa$}
            \Let{M}{\emptyset}
            \State $\tilde\chain \leftarrow$ maxvalid$(C, \bar M[i])$ \Comment{Adopt Longest Chain in the network}
            \If{$\tilde\chain \neq \chain$}
                \Let{M}{\{\tilde\chain\}}
                \Let{\chain}{\tilde\chain}
            \EndIf
            \Let{x}{\textsc{Input}()} \Comment{Take all transactions in mempool}
            \Let{B}{\textsf{PoW}(x, \tilde\chain)}
            \If{$B \neq \bot$} \Comment{Successful Mining}
                \Let{\chain}{\chain \conc B} \Comment{Add block to current longest chain}
                \Let{M}{M \cup \{\chain\}}
            \EndIf
            \State {\textsf{round}} $\leftarrow$ {\textsf{round}+1}
            \State\Return$M$
        \EndFunction
        \Function{$\textsf{Read}$}{}
            \Let{x}{[\,]} \Comment{Instantiate transactions}
            \For{$B \in \chain$}
                \Let{x}{x \conc \chain.x} \Comment{Extract all transactions from each block in the chain}
            \EndFor
            \State\Return{$x$}
        \EndFunction
        \vskip8pt
    \end{algorithmic}
\end{algorithm}
\end{figure}

\section{Proof-of-Work}
The algorithm below is run by miners to find a new block. Notice that all parties (adversarial and honest) have a maximum number of $q$ queries per round. This is to model the hash rate of parties. Furthermore, we construct a block as the concatenation of the previous block $s$, the transactions $x$, and the nonce $ctr$. For a block to be mined successfully, we require that $H(B) \leq T$, where $T$ is the mining target. Due to the size of the space $\{0, 1\}^{\kappa}$, the probability of two parties mining with the same nonce is negligible, therefore we may assume that there are no ``nonce collisions''.

\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.pow} The Proof-of-Work discovery algorithm}
    \begin{algorithmic}[1]
      \Function{$\textsf{pow}_{H,T,q}$}{$x, s$}
          \State{$ctr \overset{\$}{\leftarrow} \{0,1\}^\kappa$} \Comment{Randomly sample Nonce}
          \For{$i \gets 1 \text{ to } q$} \Comment{Number of available queries per party}
              \State $B \leftarrow s || x || ctr$ \Comment{Create block}
              \If{$H(B) \leq T$} \Comment{Successful Mining}
                  \State\Return{$B$}
              \EndIf
              \Let{\ctr}{\ctr + 1}
          \EndFor
          \State\Return{$\bot$} \Comment{Unsuccessful Mining}
      \EndFunction
    \end{algorithmic}
\end{algorithm}
\end{figure}

\section{Longest Chain}
This algorithm is run by honest nodes in order to adopt the longest chain each round. Since every honest node abides to the longest chain rule, the conditions are required for a chain to be adopted: the chain is valid and the chain is strictly longer (line 4). This algorithm is called in line 2 of the honest party algorithm: it will loop through every chain it received through the gossip network, check its validity and check that it is longer than the currently adopted chain.
\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.maxvalid} The maxvalid algorithm}
    \begin{algorithmic}[1]
    \Function{$\textsf{maxvalid}_{\mathcal{G},\delta(\cdot)}$}{$\overline{C}$}
        \State $C_\textsf{max} \leftarrow [\mathcal{G}]$ \Comment{Start with current adopted chain}
        \For{$C \in \overline{C}$} \Comment{Iterate for every chain received through gossip network}
            \If{$\textsf{validate}_{\mathcal{G},\delta(\cdot)}(C) \land |C| > |C_\textsf{max}|$} \Comment{Longest Chain Rule}
                \State $C_\textsf{max} \leftarrow C$
            \EndIf
        \EndFor
        \State\Return{$C_\textsf{max}$}
    \EndFunction
    \end{algorithmic}
\end{algorithm}
\end{figure}

\section{Validating a block}
This algorithm is used to validate a block, it is called in line 4 of the longest chain algorithm run by honest parties. The algorithm first checks that the Genesis block the chain is correct (line 2). Then for every block in the chain, the algorithm will update the UTXO, checking that each transaction is valid (lines 13-16). The algorithm will also check the PoW for each block and check that the block is in the correct format of $s || x || ctr$ (lines 9-12)
\begin{figure}[H]
\begin{algorithm}[H]
    \caption{\label{alg.validate} The validate algorithm}
    \begin{algorithmic}[1]
    \Function{$\textsf{validate}_{\mathcal{G},\delta(\cdot)}$}{$C$}
        \If{$C[0] \neq \mathcal{G}$} \Comment{Check that first block is Genesis}
            \State\Return$\false$
        \EndIf
        \State st $\leftarrow$ st$_0$ \Comment{Start at Genesis state}
        \State $h \leftarrow H(C[0])$
        \State st $\leftarrow \delta^*(st, C[0].x)$
        \For{$B \in C[1{:}]$} \Comment{Iterate for every block in the chain}
            \State $(s, x, ctr) \leftarrow B$
            \If{$H(B) > T \lor s \neq h$} \Comment{PoW check and Ancestry check}
                \State\Return$\false$
            \EndIf
            \State st $\leftarrow \delta^*(st, B.x)$ \Comment{Application Layer: update UTXO \& validate transactions}
            \If{$st = \bot$}
                \State\Return$\false$\Comment{Invalid state transition}
            \EndIf
            \State $h \leftarrow H(B)$
        \EndFor
        \State\Return$\true$
    \EndFunction
    \end{algorithmic}
\end{algorithm}
\end{figure}


\section{Chain Virtues}
Equipped with this new rigorous definition of the environment, our assumptions and the algorithm ran by the honest party, we can now mathematically define the Chain Virtues, introduced earlier in the lectures.
% \subsection{Common Prefix (\texorpdfstring{$\kappa$}{Lg})}
% $\forall$ honest parties $P_1, P_2$ adopting chains $C_1, C_2$ at rounds $r_1 \leq r_2$ respectively, Common Prefix property  $C_1[:-\kappa] \leq C_2$ holds.

\begin{enumerate}
    \item \textbf{Common Prefix (\texorpdfstring{$\kappa$}{Lg}).}
    $\forall$ honest parties $P_1, P_2$ adopting chains $C_1, C_2$ at any rounds $r_1 \leq r_2$ respectively, Common Prefix property  $C_1[:-\kappa] \leq C_2$ holds.
    \item \textbf{Chain Quality (\texorpdfstring{$\mu, \ell$}{Lg}).}
    $\forall$ honest party $P$ with adopted chain $C$,  $\forall i$ any chunk $C[i: i+\ell]$ of length $\ell > 0$ has a ratio of honest blocks $\mu$.
    \item \textbf{Chain Growth (\texorpdfstring{$\tau, s$}{Lg}).}
    $\forall$ honest parties $P$ and $\forall r_1, r_2$ with adopted chain $C_1$ at round $r_1$ and adopted chain $C_2$ at round $r_2 \geq r_1 + s$, it holds that $|C_2| \geq |C_1| + \tau s$.
\end{enumerate}

% \subsection{Chain Growth (\texorpdfstring{$\tau, s$}{Lg})}
% $\forall$ honest parties $P$ and $\forall r_1, r_2$ with adopted chain $C_1$ at round $r_1$ and adopted chain $C_2$ at round $r_2 \geq r_1 + s$, Chain Growth condition $|C_2| \geq |C_1| + \tau s$ holds.

% \subsection{Successful Round (\texorpdfstring{$r$}{Lg})}
We define a round during which one or more honest party found block as a \textbf{successful round (\texorpdfstring{$r$}{Lg}).} A round has a \textbf{convergence opportunity(\texorpdfstring{$r$}{Lg})} if only one honest party found a block irrespective of adversarial parties.

% \subsection{Convergence Opportunity (\texorpdfstring{$r$}{Lg})}
% A round has a convergence opportunity if only one honest party found a block irrespective of adversarial parties

\section{Pairing Lemma}
\begin{lemma}
Let $B = C[i]$ for some chain $C$ s.t. $B$ was computed by an honest party $P$ during a convergence opportunity $r$. Then for any block $B'$ at position $i$ of some other chain $C'$, if $B \neq B'$, then $B'$ was adversarially computed.
\end{lemma}
\begin{proof}
Suppose for contradiction that $B'$ was mined on a round $r'$. For the sake of contradiction, assume that $B'$ was honestly computed. Thus, we need to analyze three following cases:
\begin{enumerate}
    \item Case 1: $r = r'$. This is not possible as round $r$ was a convergence opportunity.
    \item Case 2: $r < r'$. This is not possible as due to the longest chain rule, after round $r$, everybody will have adopted a chain of at least $i$ blocks, so honest parties would not accept $B'$.
    \item Case 3: $r > r'$. This is not possible, same as above but this time honest parties wouldn't adopt block $B$.
\end{enumerate}
So we have a contradiction, thus, $B'$ must have been adversarially mined.
\end{proof}

From the above, we note that,
if the adversary wants to displace block $B$, she has to pay for it by mining $B'$. Therefore, if the adversary does not mine a block, then the convergence opportunity will be a true honest convergence.

\section{Honest Majority Assumption (\texorpdfstring{$n, t, \delta$}{Lg})}
We will now give a new definition of the honest majority assumption by introducing the honest advantage parameter $\delta$ . We will see in the next lecture that we need this parameter in order the chain virtues hold for Bitcoin. We say that the honest majority assumption holds if $t < (1 - \delta)(n - t)$.

\section*{Problems}
\begin{problems}
    \item Go back to Lemma~\ref{lem.honest-convergence}. Restate it and prove it formally in the model developed in this chapter.
\end{problems}

\section{Further Reading}
Even though Satoshi Nakamoto developed the first blockchain and wrote the paper about it, he did
not prove that blockchains are secure against \emph{all} adversaries within that paper. Instead,
he showed that Bitcoin is secure against the \emph{specific} Nakamoto adversary which we studied
in the previous chapters. At a later time, Juan Garay, Aggelos Kiayias, and Nikos Leonardos
wrote the \emph{Bitcoin Backbone} paper~\cite{backbone}.
The Bitcoin Backbone paper formalizes and proves that blockchains that use Proof-of-Work
are secure. This is the model we have presented in this chapter, with minor modifications.

There are a few other approaches to proving that Bitcoin is secure. One proof is by
Rafael Pass and Elaine Shi~\cite{rethinking-consensus}. Another is Ling Ren's
``Analysis of Nakamoto Consensus''~\cite{ling-analysis}. Ling's proof is in a continuous-time
model in which the hash queries are modeled as a Poisson process, which renders it simpler
in some ways. One important result in the continuous-time model is that the private mining
attack, which we studied in Chapter~\ref{chapter.attack}, is the \emph{best possible} attack
an adversary can mount~\cite{nakamoto-wins}. Given this understanding, it becomes sufficient
to study under which conditions an adversary cannot mine a private chain faster than the block tree of
honest parties grows.

Katz and Lindell have a short chapter on the modeling of the hash function as a random oracle
in their \emph{Modern Cryptography}~\cite{katz}. The model was popularized by Mihir Bellare
and Phillip Rogaway in their paper \emph{Random Oracles are Practical: A Paradigm for Designing
Efficient Protocols}~\cite{ro}, but later challenged in the well-cited article \emph{The Random
Oracle Methodology, Revisited}~\cite{ro-revisited}. Random oracles have a history prior to their introduction in
cryptography, first appearing in complexity theory. One famous appearance was in
the paper ``Relative to a Random Oracle $A$, $\textsf{P}^A \neq \textsf{NP}^A$
with Probability $1$'' by Bennett and Gill~\cite{p-vs-np-randomoracle}, following the earlier seminal
work of Baker, Gill, and Solovay on the \textsf{P} vs \textsf{NP} relativization
barrier~\cite{relativization-barrier}.